请阅读：[源代码的编译过程](https://liupj.top/dev-c-on-linux/#/docs/1)

#### <> vs ""

```c
// 这俩有啥区别 ？？？
#include <stdio.h>
#include "stdio.h"
```

> 使用`--verbose`编译选项来阅读命令的日志，往往会为我们探究问题提供帮助

![image-20220402161801154](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220402161801154.png)

```bash
> gcc file.c --verbose

#include "..." 搜索从这里开始：
#include <...> 搜索从这里开始：
  /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/include
  /usr/local/include
  /usr/lib/gcc/x86_64-pc-linux-gnu/11.2.0/include-fixed
  /usr/include
搜索列表结束。
```

> 不难发现「二者默认搜索的路径不一样」

请阅读：[重要编译选项](https://liupj.top/dev-c-on-linux/#/docs/2)

#### 有趣的预编译

```c
#include <stdio.h>

int main() {
#ifdef __x86_64__
	printf("__x86_64__\n"); // gcc curFile.c         && ./a.out => 输出本行
#else
	printf("X86\n");        // gcc curFile.c -m32    && ./a.out => 输出本行
#endif
}
```

#### 宏定义与展开

> 宏展开：通过「复制/粘贴」改变代码的形态；反复粘贴，直到没有宏可以展开为止

- #include -> 粘贴文件内容

![image-20220402093422109](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220402093422109.png)

- aa，bb -> 粘贴符号

```c
#include <stdio.h>

int main() {
#if aa == bb            // 预编译的变量是无需声明就可使用的；由于 aa 和 bb 初始值都为空，因此二者确实相等
	printf("Yes\n");    // 因此这里会输出 ！
#else
	printf("No\n");
#endif
}
```

- 体验一下预编译的这种「复制/粘贴」的威力

```c
// 如何搞垮一个 OJ ？
#define TEN(X) X X X X X X X X X X
#define A "aaaaaaaaaa"
#define B TEN(A)
#define C TEN(B)
#define D TEN(C)
#define E TEN(D)
#define F TEN(E)
#define G TEN(F)
int main() {
	puts(G);
}
```

```c
// 如何毁掉一个身边的同学 ？
#define true (__LINE__ % 2 != 0)

#include <stdio.h>
int main() {
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
  if (true) printf("%d\n", __LINE__);
}
```

#### 关于 \#\#

- \#\# 可以将其左右两侧的字符串拼接起来

- eg：某些 OJ 平台不允许用户调用系统的 API，有没有什么比较 hack 的方法可以躲过 OJ 的关键字检测 ？

```c
#define A sys ## tem
int main() {
	A("echo Hello\n");
}
```

#### 妙用 -E 编译选项

> 就像下图中这种难以用肉眼进行宏展开的源代码，其实可以用 -E 编译选项来帮助我们

![image-20220403101039458](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220403101039458.png)

#### 元编程

![image-20220406110822426](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220406110822426.png)

- 类似上面这样的代码编写方式也叫元编程（meta-programming）

  - 优点：写法接近自然语言，且用法灵活

  - 缺点：降低了代码的可读性，一些不是那么强大的代码分析工具可能会认为元编程的代码不符合正常语法...

```c
#define L (
int main L) { puts L "Hello" ); }
```

#### 联想

> 元编程其实有（封装 & 复用）的思想，元编程在实际的大型编码工作中很常用 ！

- c++ 中的模板元编程、Rust 中的 macros、...
