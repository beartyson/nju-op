#### 为什么要理解内存模型

- 既然

	1. 一段连续的 C 代码总能对应到一段连续的机器指令

	2. C 代码的执行状态总能对应到机器的状态

	- eg：函数、变量、指针、... <===> 内存、地址、寄存器、...

- 而且（不太严谨地）：内存 = 代码 + 数据 + 堆栈

<img src="https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220404152923472.png" alt="image-20220404152923472" style="zoom:50%;" />

- 因此：要理解 C 程序执行，最需要了解的东西就是「内存模型」！

#### C 语言中的所有东西，都可以用（指针 和 内存）来理解

- 比如我们定义了一个变量 x=1，其实背后所做的事情就是

	- 有一个指针指向 x 所在的内存区块（*p = &x）

	- 然后以（*p = 1）的方式给 x 进行初始化

![image-20220403154302316](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220403154302316.png)

#### 例题

```c
int main() {
  int * ptr = (void *) 1;
  *ptr = 1;
}

/*

首先，由于数组以字节为单位，所以一个内存地址实际上就是一个整数，对应某个字节

其次，任何一个地址我们都可以有指针指向它，完全没问题

本例中，main 函数体的首行代码中的 1 是对应某个字节的地址

可是，观察 main 函数体的第二行代码，显然我们有可能越权访问指针所指向的内存

也就导致了 segmentation fault（when run）

*/
```

#### 一切均可取地址

```c
/**
 * 工具函数
 * 1. 输出指针变量中保存的地址（即：指针指向的地址）
 * 2. 将指针指向的内存区域以 long 来解读，并以 16 进制 16 位的格式进行输出
 */
void _printPtr(void * ptr) {
	printf("ptr = %p, *ptr = %016lx\n", ptr, *(long *)ptr);
}
```

```c
int main() {
  int arr[10];
  _printPtr(arr);
  _printPtr(&arr);
  _printPtr(&arr[0]);
}
```

```c
int main() {
  _printPtr(main);
  _printPtr(&main);
}
```
