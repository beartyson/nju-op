#### 为什么 C 不允许函数重名，而 C++ 却支持函数重载（允许函数重名）？

- 如下代码

  - 以 C 的规范解析 foo 函数

  - 以 C++ 的规范解析 bar 函数

![image-20220403120428793](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220403120428793.png)

`Z 表示函数的返回值类型为 int`、`3 表示 bar 字符串的长度`、`v 表示函数无参数`

- C++ 的这种对中间代码的函数名的命名规范

- 使得在 C++ 源码中，即使函数重名，但只要（参数不同 || 返回值类型不同），就能确保在中间代码中，函数名唯一

- 所以 C++ 就支持了函数重载

#### main 函数的参数

- argc（argument count）、argv（argument vector）

![image-20220407180058912](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220407180058912.png)

- argc 表示命令行传入的参数的个数

- argv 是参数列表

  - argv[0] 是命令本身

  - argv[argc] 是 NULL

![image-20220403223328225](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220403223328225.png)

![image-20220403223911575](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220403223911575.png)

#### char * argv[] 的等价写法

`char * argv[] == (char *) * argv == char **argv`

- 理解方式（类比`int * ptr`）：

  - 先不用看内存被解读成什么，`argv`首先是一个指针

  - 该指针指向的内存被解读为`char *`
