![image-20220405120027516](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220405120027516.png)

![image-20220405121735559](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220405121735559.png)

#### 例题

![image-20220403161912606](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220403161912606.png)

![image-20220403161008885](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220403161008885.png)

```c
void printPtr(void * ptr) {
	/*
		每次输出的都不一样 ？？？！
		这是因为：每次将可执行文件加载到内存运行，系统都会为变量 a 开辟一块内存空间
	*/
	printf("%p\n", ptr);
	
	/*
		1. 将指向的内存解读为 long，即 8 字节共 64 位的比特
		2. 输出格式控制：16 进制 16 位
	*/
	printf("%016lx\n", *(long *)ptr);
}

int main() {
	int a = 123;
	printPtr(&a);
}
```

#### 例题

![image-20220405120618387](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220405120618387.png)

#### char * argv[] 的等价写法

`char * argv[] === char *(*argv) === char **argv`

- 理解方式（类比`int *ptr`）：

  - 先不用看内存被解读成什么，`argv`首先是一个指针

  - 该指针指向的内存被解读为`char *`

![image-20220405131324182](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220405131324182.png)

> 注意：所有的（变量、参数、局部变量）都会在内存的堆栈上

#### argv + 1

![image-20220405131950833](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220405131950833.png)
